# ğŸ” KioskoTouch - AnÃ¡lisis Completo de Base de Datos

## ğŸ“‹ Tabla de Contenidos
- [ğŸ¯ Resumen Ejecutivo](#-resumen-ejecutivo)
- [ğŸ›’ Flujo de Compra Completo](#-flujo-de-compra-completo)
- [ğŸ“¦ Flujo de Registro de Productos](#-flujo-de-registro-de-productos)
- [ğŸ” AnÃ¡lisis Profundo de Integridad](#-anÃ¡lisis-profundo-de-integridad)
- [ğŸš€ Sugerencias de Mejora](#-sugerencias-de-mejora)

---

## ğŸ¯ **Resumen Ejecutivo**

### **Stack TecnolÃ³gico**
- **Backend:** Django 5.1.7 + Django REST Framework 3.16.0
- **Base de Datos:** MySQL con mysqlclient 2.2.7
- **AutenticaciÃ³n:** JWT con djangorestframework_simplejwt 5.5.0
- **Media:** Pillow 11.2.1 para manejo de imÃ¡genes

### **Arquitectura de Base de Datos**
- âœ… **47 tablas** organizadas en 6 mÃ³dulos principales
- âœ… **Integridad referencial** completa con foreign keys
- âœ… **Soft deletes** implementados con estados
- âœ… **Multimedia centralizada** en tabla de imÃ¡genes
- âœ… **PersonalizaciÃ³n avanzada** de productos con ingredientes

---

## ğŸ›’ **Flujo de Compra Completo**

### **1ï¸âƒ£ INICIO DE SESIÃ“N EN KIOSKO**
```sql
-- Cliente se acerca al kiosko
INSERT INTO appKiosko_PedidoSessions (
    kiosko_touch_id, 
    fecha_inicio_pedido
) VALUES (1, NOW());

-- Estado: SesiÃ³n iniciada, pedido_id = NULL (aÃºn no hay pedido)
```

### **2ï¸âƒ£ NAVEGACIÃ“N POR CATEGORÃAS**
```sql
-- Cliente ve categorÃ­as disponibles
SELECT c.*, COUNT(p.id) as productos_disponibles
FROM appKiosko_Categorias c
LEFT JOIN appKiosko_Productos p ON c.id = p.categoria_id
INNER JOIN appKiosko_Estados e ON p.estado_id = e.id
WHERE e.is_active = TRUE AND e.is_eliminated = FALSE
GROUP BY c.id;

-- Cliente ve productos de una categorÃ­a
SELECT p.*, c.nombre as categoria_nombre
FROM appKiosko_Productos p
INNER JOIN appKiosko_Categorias c ON p.categoria_id = c.id  
INNER JOIN appKiosko_Estados e ON p.estado_id = e.id
WHERE c.id = 1 AND e.is_active = TRUE;
```

### **3ï¸âƒ£ VER DETALLES DEL PRODUCTO Y PERSONALIZACIÃ“N**
```sql
-- Cliente selecciona hamburguesa clÃ¡sica
SELECT p.*, 
       GROUP_CONCAT(CONCAT(i.nombre, ' (', 
           CASE WHEN pi.es_base THEN 'incluido' ELSE 'extra +$', i.precio_adicional END, 
           ')')) as ingredientes
FROM appKiosko_Productos p
LEFT JOIN appKiosko_Productos_Ingredientes pi ON p.id = pi.producto_id
LEFT JOIN appKiosko_Ingredientes i ON pi.ingrediente_id = i.id
WHERE p.id = 1
GROUP BY p.id;

-- Ingredientes base del producto
SELECT i.*, pi.es_base, pi.permite_extra
FROM appKiosko_Ingredientes i
INNER JOIN appKiosko_Productos_Ingredientes pi ON i.id = pi.ingrediente_id
WHERE pi.producto_id = 1;
```

### **4ï¸âƒ£ PERSONALIZACIÃ“N Y CARRITO**
```sql
-- Cliente personaliza: quita lechuga, agrega queso extra
-- (Se guarda temporalmente en el frontend hasta confirmar pedido)

-- Datos del carrito temporal:
-- Producto: Hamburguesa ClÃ¡sica - $8.99
-- Modificaciones: 
--   - Quitar lechuga (precio: $0.00)
--   - Agregar queso extra (precio: +$1.50)
-- Total item: $10.49
```

### **5ï¸âƒ£ CREACIÃ“N DEL PEDIDO**
```sql
-- Cliente confirma compra - se crea el pedido
INSERT INTO appKiosko_Pedidos (
    invoice_number,
    tipo_entrega,
    total,
    numero_mesa,
    cliente_id,
    valor_descuento,
    tipo_pago_id,
    fecha_pago,
    estado_id
) VALUES (
    'INV-2025-001234',
    'mesa',
    10.49,
    5,
    NULL, -- cliente anÃ³nimo
    0.00,
    1, -- efectivo
    NOW(),
    1  -- estado: en preparaciÃ³n
);

-- Obtener ID del pedido reciÃ©n creado
SET @pedido_id = LAST_INSERT_ID();
```

### **6ï¸âƒ£ DETALLES DEL PEDIDO**
```sql
-- Agregar producto al detalle del pedido
INSERT INTO appKiosko_DetallePedido (
    pedido_id,
    producto_id,
    menu_id,
    cantidad,
    precio_unitario,
    subtotal
) VALUES (
    @pedido_id,
    1, -- hamburguesa clÃ¡sica
    NULL,
    1,
    8.99,
    8.99
);

-- Registrar personalizaciones del cliente
INSERT INTO appKiosko_Pedido_Producto_Ingredientes (
    pedido_id,
    producto_id,
    ingrediente_id,
    accion,
    precio_aplicado
) VALUES 
(@pedido_id, 1, 6, 'quitar', 0.00), -- quitar lechuga
(@pedido_id, 1, 4, 'extra', 1.50);  -- queso extra
```

### **7ï¸âƒ£ ACTUALIZAR SESIÃ“N Y FINALIZAR**
```sql
-- Vincular pedido con la sesiÃ³n del kiosko
UPDATE appKiosko_PedidoSessions 
SET pedido_id = @pedido_id,
    fecha_fin_pedido = NOW()
WHERE id = @session_id;

-- Enviar pedido a pantalla de cocina
-- (Mediante WebSocket o polling desde el frontend de cocina)
```

### **8ï¸âƒ£ FLUJO EN COCINA** 
```sql
-- Cocina ve pedidos pendientes
SELECT p.*, 
       p.numero_mesa,
       p.invoice_number,
       GROUP_CONCAT(
           CONCAT(pr.nombre, ' x', dp.cantidad, 
                  CASE WHEN ppi.accion IS NOT NULL 
                       THEN CONCAT(' (', ppi.accion, ' ', i.nombre, ')') 
                       ELSE '' END)
       ) as items_pedido
FROM appKiosko_Pedidos p
INNER JOIN appKiosko_DetallePedido dp ON p.id = dp.pedido_id
INNER JOIN appKiosko_Productos pr ON dp.producto_id = pr.id
LEFT JOIN appKiosko_Pedido_Producto_Ingredientes ppi ON p.id = ppi.pedido_id AND pr.id = ppi.producto_id
LEFT JOIN appKiosko_Ingredientes i ON ppi.ingrediente_id = i.id
INNER JOIN appKiosko_Estados e ON p.estado_id = e.id
WHERE e.nombre = 'En PreparaciÃ³n'
GROUP BY p.id
ORDER BY p.created_at;
```

---

## ğŸ“¦ **Flujo de Registro de Productos**

### **1ï¸âƒ£ CREAR CATEGORÃA (si no existe)**
```sql
-- Administrador crea categorÃ­a "Hamburguesas"
INSERT INTO appKiosko_Categorias (nombre) 
VALUES ('Hamburguesas');

SET @categoria_id = LAST_INSERT_ID();
```

### **2ï¸âƒ£ CREAR ESTADO ACTIVO (si no existe)**
```sql
-- Verificar que existe estado activo
SELECT id FROM appKiosko_Estados 
WHERE nombre = 'Activo' AND is_active = TRUE;

-- Si no existe, crearlo
INSERT INTO appKiosko_Estados (nombre, is_active, is_eliminated, is_inactive) 
VALUES ('Activo', TRUE, FALSE, FALSE);
```

### **3ï¸âƒ£ REGISTRAR PRODUCTO BASE**
```sql
-- Crear producto "Hamburguesa BBQ Deluxe"
INSERT INTO appKiosko_Productos (
    nombre,
    descripcion,
    precio,
    categoria_id,
    estado_id
) VALUES (
    'Hamburguesa BBQ Deluxe',
    'Jugosa hamburguesa con carne de res, queso cheddar, cebolla caramelizada, lechuga, tomate y salsa BBQ especial. Servida con papas fritas.',
    12.99,
    @categoria_id,
    1  -- estado activo
);

SET @producto_id = LAST_INSERT_ID();
```

### **4ï¸âƒ£ REGISTRAR INGREDIENTES**
```sql
-- Crear ingredientes base (si no existen)
INSERT INTO appKiosko_Ingredientes (nombre, precio_adicional, estado_id) VALUES
('Pan de hamburguesa premium', 0.00, 1),
('Carne de res 150gr', 0.00, 1),
('Queso cheddar', 0.00, 1),
('Lechuga iceberg', 0.00, 1),
('Tomate fresco', 0.00, 1),
('Cebolla caramelizada', 0.00, 1),
('Salsa BBQ casera', 0.00, 1),
('Pepinillos', 1.00, 1), -- ingrediente extra
('Bacon ahumado', 2.50, 1), -- ingrediente extra
('Carne extra', 3.00, 1); -- ingrediente extra
```

### **5ï¸âƒ£ ASOCIAR INGREDIENTES AL PRODUCTO**
```sql
-- Ingredientes base (vienen incluidos)
INSERT INTO appKiosko_Productos_Ingredientes (
    producto_id, 
    ingrediente_id, 
    es_base, 
    permite_extra
) VALUES
(@producto_id, 1, TRUE, FALSE), -- pan (base, no permite extra)
(@producto_id, 2, TRUE, TRUE),  -- carne (base, permite extra)
(@producto_id, 3, TRUE, FALSE), -- queso (base, no permite extra)
(@producto_id, 4, TRUE, FALSE), -- lechuga (base, no permite extra)
(@producto_id, 5, TRUE, FALSE), -- tomate (base, no permite extra)
(@producto_id, 6, TRUE, FALSE), -- cebolla (base, no permite extra)
(@producto_id, 7, TRUE, FALSE); -- salsa BBQ (base, no permite extra)

-- Ingredientes solo como extras
INSERT INTO appKiosko_Productos_Ingredientes (
    producto_id, 
    ingrediente_id, 
    es_base, 
    permite_extra
) VALUES
(@producto_id, 8, FALSE, FALSE), -- pepinillos (solo extra)
(@producto_id, 9, FALSE, FALSE), -- bacon (solo extra)
(@producto_id, 10, FALSE, FALSE); -- carne extra (solo extra)
```

### **6ï¸âƒ£ SUBIR IMÃGENES DEL PRODUCTO**
```sql
-- Registrar imagen principal del producto
INSERT INTO appKiosko_Imagen (
    nombre,
    ruta,
    categoria_imagen,
    entidad_relacionada_id
) VALUES (
    'hamburguesa_bbq_deluxe_principal.jpg',
    '/media/productos/hamburguesa_bbq_deluxe_principal.jpg',
    'producto',
    @producto_id
);

-- Registrar imÃ¡genes adicionales
INSERT INTO appKiosko_Imagen (
    nombre,
    ruta,
    categoria_imagen,
    entidad_relacionada_id
) VALUES 
('hamburguesa_bbq_deluxe_detalle1.jpg', '/media/productos/hamburguesa_bbq_deluxe_detalle1.jpg', 'producto', @producto_id),
('hamburguesa_bbq_deluxe_detalle2.jpg', '/media/productos/hamburguesa_bbq_deluxe_detalle2.jpg', 'producto', @producto_id);
```

### **7ï¸âƒ£ CREAR MENÃš CON EL PRODUCTO (opcional)**
```sql
-- Crear menÃº "Combo BBQ Deluxe"
INSERT INTO appKiosko_Menus (
    nombre,
    descripcion,
    precio,
    tipo_menu,
    estado_id
) VALUES (
    'Combo BBQ Deluxe',
    'Hamburguesa BBQ Deluxe + Papas fritas grandes + Gaseosa 500ml',
    15.99,
    'combo',
    1
);

SET @menu_id = LAST_INSERT_ID();

-- Asociar productos al menÃº
INSERT INTO appKiosko_MenuProductos (
    producto_id,
    menu_id,
    cantidad
) VALUES 
(@producto_id, @menu_id, 1), -- 1 hamburguesa BBQ
(25, @menu_id, 1), -- 1 papas grandes (asumiendo ID 25)
(30, @menu_id, 1); -- 1 gaseosa (asumiendo ID 30)
```

### **8ï¸âƒ£ VALIDACIÃ“N Y TESTING**
```sql
-- Verificar que el producto quedÃ³ bien configurado
SELECT 
    p.nombre as producto,
    p.precio,
    c.nombre as categoria,
    e.nombre as estado,
    COUNT(pi.ingrediente_id) as total_ingredientes,
    COUNT(img.id) as total_imagenes
FROM appKiosko_Productos p
INNER JOIN appKiosko_Categorias c ON p.categoria_id = c.id
INNER JOIN appKiosko_Estados e ON p.estado_id = e.id
LEFT JOIN appKiosko_Productos_Ingredientes pi ON p.id = pi.producto_id
LEFT JOIN appKiosko_Imagen img ON p.id = img.entidad_relacionada_id AND img.categoria_imagen = 'producto'
WHERE p.id = @producto_id
GROUP BY p.id;

-- Ver detalle de ingredientes del producto
SELECT 
    i.nombre as ingrediente,
    i.precio_adicional,
    pi.es_base,
    pi.permite_extra,
    CASE 
        WHEN pi.es_base = TRUE THEN 'Incluido'
        ELSE 'Solo extra'
    END as tipo
FROM appKiosko_Ingredientes i
INNER JOIN appKiosko_Productos_Ingredientes pi ON i.id = pi.ingrediente_id
WHERE pi.producto_id = @producto_id
ORDER BY pi.es_base DESC, i.nombre;
```

---

## ğŸ” **AnÃ¡lisis Profundo de Integridad**

### **ğŸ¯ Validaciones crÃ­ticas del flujo:**

#### **1. Reglas de Negocio Implementadas**
- âœ… **PersonalizaciÃ³n de ingredientes:** Cliente puede quitar todos excepto 1
- âœ… **Precios dinÃ¡micos:** Ingredientes extra se calculan correctamente
- âœ… **Soft deletes:** Estados permiten ocultar en lugar de eliminar
- âœ… **Trazabilidad completa:** Cada pedido tiene su sesiÃ³n de kiosko
- âœ… **Multimedia centralizada:** ImÃ¡genes y videos en tablas especializadas

#### **2. Integridad Referencial**
```sql
-- Ejemplos de constraints importantes:
FOREIGN KEY (cliente_id) REFERENCES appKiosko_clientes(id) ON DELETE SET NULL
FOREIGN KEY (pedido_id) REFERENCES appKiosko_Pedidos(id) ON DELETE CASCADE
UNIQUE KEY unique_empleado_establecimiento_activo (establecimiento_id, empleado_id, fecha_inicio_trabajo)
```

#### **3. Validaciones a Nivel de AplicaciÃ³n (Django)**
```python
# ValidaciÃ³n personalizaciÃ³n de ingredientes
def validar_personalizacion_producto(producto_id, ingredientes_quitar):
    ingredientes_base = ProductosIngredientes.objects.filter(
        producto_id=producto_id, 
        es_base=True
    ).count()
    
    if len(ingredientes_quitar) >= ingredientes_base:
        raise ValidationError("Debe mantener al menos 1 ingrediente en el producto")
    
    return True

# ValidaciÃ³n horarios de negocio
def validar_horario_pedido():
    now = timezone.now().time()
    if not (time(6, 0) <= now <= time(23, 0)):
        raise ValidationError("Pedidos solo permitidos de 6:00 AM a 11:00 PM")
```

### **ğŸš¨ Ãreas que necesitan atenciÃ³n:**

#### **1. GestiÃ³n de Stock/Inventario**
- âŒ **Falta:** Control de inventario de ingredientes
- âŒ **Falta:** ValidaciÃ³n de disponibilidad en tiempo real
- ğŸ’¡ **Sugerencia:** Agregar tabla `appKiosko_Stock` para inventario

#### **2. Estados de Pedido mÃ¡s Granulares**
```sql
-- Estados sugeridos para pedidos:
INSERT INTO appKiosko_Estados (nombre) VALUES 
('Recibido'),           -- Pedido creado
('En Cola'),            -- Esperando preparaciÃ³n  
('En PreparaciÃ³n'),     -- Cocinando
('Listo'),              -- Terminado, esperando entrega
('Entregado'),          -- Cliente recibiÃ³ pedido
('Cancelado');          -- Pedido cancelado
```

#### **3. Validaciones de Horarios**
```sql
-- Agregar campos Ãºtiles a productos
ALTER TABLE appKiosko_Productos 
ADD COLUMN tiempo_preparacion INT DEFAULT 10,
ADD COLUMN disponible_desde TIME DEFAULT '06:00:00',
ADD COLUMN disponible_hasta TIME DEFAULT '23:00:00';
```

---

## ğŸš€ **Sugerencias de Mejora**

### **ğŸ“Š 1. MÃ©tricas y Analytics**
```sql
-- Tabla para tracking de analytics
CREATE TABLE IF NOT EXISTS appKiosko_Analytics (
    id INT PRIMARY KEY AUTO_INCREMENT,
    evento VARCHAR(50) NOT NULL,
    kiosko_touch_id INT,
    producto_id INT,
    metadata JSON,
    fecha_evento TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (kiosko_touch_id) REFERENCES appKiosko_KioskosTouch(id),
    FOREIGN KEY (producto_id) REFERENCES appKiosko_Productos(id)
);
```

### **ğŸ“± 2. Notificaciones Push**
```sql
-- Tabla para gestionar notificaciones
CREATE TABLE IF NOT EXISTS appKiosko_Notificaciones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    tipo VARCHAR(50) NOT NULL,
    titulo VARCHAR(100) NOT NULL,
    mensaje TEXT NOT NULL,
    pedido_id INT,
    enviado BOOLEAN DEFAULT FALSE,
    fecha_envio TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (pedido_id) REFERENCES appKiosko_Pedidos(id)
);
```

### **ğŸ”§ 3. Configuraciones DinÃ¡micas**
```sql
-- Tabla para configuraciones del sistema
CREATE TABLE IF NOT EXISTS appKiosko_Configuraciones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    clave VARCHAR(100) NOT NULL UNIQUE,
    valor TEXT NOT NULL,
    descripcion TEXT,
    tipo ENUM('string', 'integer', 'boolean', 'json') DEFAULT 'string',
    establecimiento_id INT,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (establecimiento_id) REFERENCES appKiosko_Establecimientos(id)
);

-- Configuraciones ejemplo
INSERT INTO appKiosko_Configuraciones (clave, valor, descripcion, tipo) VALUES
('horario_apertura', '06:00', 'Hora de apertura del establecimiento', 'string'),
('horario_cierre', '23:00', 'Hora de cierre del establecimiento', 'string'),
('tiempo_inactividad_kiosko', '300', 'Segundos antes de resetear kiosko por inactividad', 'integer'),
('permitir_pedidos_anonimos', 'true', 'Permitir pedidos sin registro de cliente', 'boolean');
```

### **ğŸ’³ 4. IntegraciÃ³n con Pasarelas de Pago**
```sql
-- Tabla para transacciones de pago
CREATE TABLE IF NOT EXISTS appKiosko_TransaccionesPago (
    id INT PRIMARY KEY AUTO_INCREMENT,
    pedido_id INT,
    metodo_pago ENUM('efectivo', 'tarjeta', 'transferencia', 'qr') NOT NULL,
    monto DECIMAL(10,2) NOT NULL,
    estado_transaccion ENUM('pendiente', 'aprobada', 'rechazada', 'reembolsada') NOT NULL,
    referencia_externa VARCHAR(100),
    datos_respuesta JSON,
    fecha_transaccion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (pedido_id) REFERENCES appKiosko_Pedidos(id)
);
```

### **ğŸ“ˆ 5. Queries de Reportes Ãštiles**
```sql
-- Productos mÃ¡s vendidos
SELECT p.nombre, COUNT(dp.id) as veces_vendido, SUM(dp.subtotal) as ingresos_total
FROM appKiosko_Productos p
INNER JOIN appKiosko_DetallePedido dp ON p.id = dp.producto_id
INNER JOIN appKiosko_Pedidos ped ON dp.pedido_id = ped.id
WHERE ped.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY p.id
ORDER BY veces_vendido DESC
LIMIT 10;

-- Ingredientes mÃ¡s quitados
SELECT i.nombre, COUNT(ppi.id) as veces_quitado
FROM appKiosko_Ingredientes i
INNER JOIN appKiosko_Pedido_Producto_Ingredientes ppi ON i.id = ppi.ingrediente_id
WHERE ppi.accion = 'quitar'
AND ppi.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY i.id
ORDER BY veces_quitado DESC;

-- Ventas por hora
SELECT 
    HOUR(created_at) as hora,
    COUNT(*) as cantidad_pedidos,
    SUM(total) as ingresos
FROM appKiosko_Pedidos
WHERE DATE(created_at) = CURDATE()
GROUP BY HOUR(created_at)
ORDER BY hora;
```

---

## ğŸ¯ **Conclusiones**

### **âœ… Fortalezas del DiseÃ±o Actual**
1. **Arquitectura sÃ³lida** con separaciÃ³n clara de responsabilidades
2. **Flexibilidad en personalizaciÃ³n** de productos e ingredientes
3. **Trazabilidad completa** del flujo de pedidos
4. **Multimedia centralizada** para fÃ¡cil gestiÃ³n
5. **Soft deletes** implementados correctamente
6. **Soporte completo** para menÃºs y promociones

### **ğŸ”„ Ãreas de Mejora Prioritarias**
1. **GestiÃ³n de inventario** para ingredientes
2. **Estados de pedido mÃ¡s granulares** para mejor tracking
3. **Validaciones de horarios** de operaciÃ³n
4. **Sistema de notificaciones** para cocina y clientes
5. **Analytics y reportes** para toma de decisiones

### **ğŸš€ TecnologÃ­as Recomendadas para ImplementaciÃ³n**
- **WebSockets:** Para actualizaciones en tiempo real (Django Channels)
- **Redis:** Para cachÃ© y sessions temporales
- **Celery:** Para tareas asÃ­ncronas (envÃ­o de notificaciones)
- **Docker:** Para containerizaciÃ³n y deploy
- **Nginx:** Para servir archivos estÃ¡ticos y balanceo

---

**ğŸ“ Documento generado el:** `29 de Mayo, 2025`  
**ğŸ”„ Ãšltima actualizaciÃ³n:** `v2.1.0`  
**ğŸ‘¨â€ğŸ’» Revisado por:** GitHub Copilot